---
title: WebSockets
description: Real-time communication in Archon
---

# WebSocket Architecture

Archon uses WebSockets for real-time features like crawl progress updates, task changes, and AI agent chat streaming. The application uses an enhanced WebSocket service that provides:

- Connection state management
- Promise-based connection establishment  
- Exponential backoff for reconnections
- Typed message handlers
- Heartbeat/keepalive support
- Better error handling and recovery

## EnhancedWebSocketService

The core WebSocket functionality is provided by the `EnhancedWebSocketService` class, which offers a robust, type-safe WebSocket implementation with automatic reconnection and state management.

### Key Features

1. **Connection State Management**: Track connection state (CONNECTING, CONNECTED, RECONNECTING, DISCONNECTED, FAILED)
2. **Promise-based Connection**: Async/await support for connection establishment
3. **Automatic Reconnection**: Exponential backoff with configurable attempts
4. **Message Type Safety**: Typed message handlers for different message types
5. **Heartbeat Support**: Automatic heartbeat to keep connections alive
6. **Error Recovery**: Comprehensive error handling with callbacks

### Basic Usage

```typescript
import { createWebSocketService, WebSocketState } from './services/EnhancedWebSocketService';

// Create a service instance
const wsService = createWebSocketService({
  enableAutoReconnect: true,
  maxReconnectAttempts: 5,
  reconnectInterval: 1000,
  heartbeatInterval: 30000
});

// Connect to endpoint
await wsService.connect('/api/endpoint');

// Add message handlers
wsService.addMessageHandler('update', (message) => {
  console.log('Received update:', message.data);
});

// Monitor connection state
wsService.addStateChangeHandler((state: WebSocketState) => {
  console.log('Connection state:', state);
});

// Send messages
wsService.send({ type: 'request', data: { id: 123 } });

// Disconnect when done
wsService.disconnect();
```

## Service-Specific Implementations

### Task Updates Service

Handles real-time task updates for project management:

```typescript
import { taskUpdateWebSocket } from './services/taskUpdateService';

await taskUpdateWebSocket.connect(projectId, {
  onTaskCreated: (task) => console.log('New task:', task),
  onTaskUpdated: (task) => console.log('Task updated:', task),
  onTaskDeleted: (task) => console.log('Task deleted:', task),
  onTasksChange: (tasks) => console.log('Tasks changed:', tasks)
});
```

### Knowledge Base Service

Manages real-time knowledge base updates:

```typescript
import { knowledgeWebSocket } from './services/knowledgeWebSocketService';

await knowledgeWebSocket.connect({
  onKnowledgeUpdate: (data) => console.log('Knowledge update:', data),
  onSourceUpdate: (data) => console.log('Source update:', data)
});
```

### Project List Service

Handles project list updates:

```typescript
import { projectListWebSocket } from './services/projectListWebSocketService';

await projectListWebSocket.connect({
  onProjectCreated: (project) => console.log('Project created:', project),
  onProjectUpdated: (project) => console.log('Project updated:', project),
  onProjectDeleted: (project) => console.log('Project deleted:', project)
});
```

### Crawl Progress Service

Streams crawling progress with enhanced features:

```typescript
import { crawlProgressServiceV2 } from './services/crawlProgressServiceV2';

await crawlProgressServiceV2.streamProgressEnhanced(progressId, {
  onMessage: (data) => console.log('Progress:', data),
  onStateChange: (state) => console.log('State:', state),
  onError: (error) => console.error('Error:', error)
});
```

### Project Creation Progress

Tracks project creation progress:

```typescript
import { projectCreationProgressService } from './services/projectCreationProgressService';

await projectCreationProgressService.streamProgress(progressId, (data) => {
  console.log('Creation progress:', data);
});
```

## Database Change Detection Pattern

To bridge MCP operations with WebSocket real-time updates, Archon uses a Database Change Detection Pattern. This pattern maintains separation of concerns by keeping MCP servers simple (no WebSocket code) while enabling real-time UI updates when AI agents modify data through MCP tools.

### How It Works

1. **MCP Tool Execution**: AI agents execute MCP tools that modify the database
2. **Change Detection**: Backend service polls database timestamps to detect changes
3. **Event Broadcasting**: Changes are broadcast to WebSocket clients
4. **UI Updates**: React components receive updates and refresh automatically

### Implementation

```python
class TaskChangeDetector:
    def __init__(self, project_id: str, ws_manager: ConnectionManager):
        self.project_id = project_id
        self.ws_manager = ws_manager
        self.last_check = datetime.utcnow()
        self.running = True
        
    async def start_monitoring(self):
        """Monitor for task changes and broadcast updates"""
        while self.running:
            try:
                # Query for changes since last check
                changed_tasks = await self._get_changed_tasks()
                
                if changed_tasks:
                    # Broadcast to all connected clients
                    await self.ws_manager.broadcast_to_project(
                        self.project_id,
                        {
                            "type": "tasks_updated",
                            "data": {
                                "updated_tasks": changed_tasks,
                                "timestamp": datetime.utcnow().isoformat()
                            }
                        }
                    )
                    
                self.last_check = datetime.utcnow()
                
            except Exception as e:
                logger.error(f"Error in change detection: {e}")
                
            await asyncio.sleep(1)  # Poll interval
```

### Benefits

1. **Separation of Concerns**: MCP servers remain simple and focused
2. **Real-time Updates**: UI stays synchronized with database changes
3. **Automatic Lifecycle**: Detectors start/stop based on WebSocket connections
4. **Incremental Updates**: Only changed data is transmitted
5. **Resilient**: Handles connection drops and reconnections gracefully

## Backend WebSocket Endpoints

The FastAPI backend provides several WebSocket endpoints:

### `/api/crawl-progress/{progress_id}`
Streams crawling progress for knowledge base updates.

### `/api/agent-chat/sessions/{session_id}/ws`
Bidirectional communication for AI agent chat with streaming responses.

### `/api/projects/{project_id}/tasks/ws`
Real-time task updates for a specific project.

### `/api/knowledge/ws`
Knowledge base updates stream.

### `/api/projects/ws`
Project list updates.

### `/api/project-creation-progress/{progress_id}`
Project creation progress updates.

## React Integration

### Hook Pattern

```typescript
import { useEffect, useState } from 'react';
import { crawlProgressServiceV2, WebSocketState } from '../services/crawlProgressServiceV2';

export function useCrawlProgress(progressId: string) {
  const [progress, setProgress] = useState(null);
  const [connectionState, setConnectionState] = useState(WebSocketState.DISCONNECTED);
  
  useEffect(() => {
    const connect = async () => {
      await crawlProgressServiceV2.streamProgressEnhanced(progressId, {
        onMessage: setProgress,
        onStateChange: setConnectionState
      });
    };
    
    connect();
    
    return () => {
      crawlProgressServiceV2.disconnectProgress(progressId);
    };
  }, [progressId]);
  
  return { progress, connectionState };
}
```

### Component Integration

```typescript
function MyComponent() {
  const { progress, connectionState } = useCrawlProgress('progress-123');
  
  if (connectionState === WebSocketState.CONNECTING) {
    return <div>Connecting...</div>;
  }
  
  if (connectionState === WebSocketState.FAILED) {
    return <div>Connection failed</div>;
  }
  
  return (
    <div>
      <h3>Progress: {progress?.percentage}%</h3>
      <p>Status: {progress?.status}</p>
    </div>
  );
}
```

## Best Practices

1. **Always Disconnect**: Clean up WebSocket connections in useEffect cleanup
2. **Handle State Changes**: Monitor connection state for better UX
3. **Use Error Callbacks**: Implement error handlers for resilience
4. **Avoid Dependency Issues**: Don't include unstable functions in useCallback dependencies
5. **Test Reconnection**: Verify automatic reconnection works properly

## Troubleshooting

### Connection Issues

1. Check browser console for WebSocket errors
2. Verify backend is running on correct port (8080)
3. Ensure no proxy/firewall blocking WebSocket connections
4. Check for proper CORS configuration

### Message Handling

1. Verify message types match between frontend and backend
2. Check for proper JSON serialization
3. Ensure message handlers are registered before connection

### Performance

1. Implement debouncing for high-frequency updates
2. Use message batching where appropriate
3. Monitor memory usage for long-lived connections
4. Consider implementing backpressure for heavy loads